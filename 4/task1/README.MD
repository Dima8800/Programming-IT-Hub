# Очередь на кольцевом буфере

В этой реализации задания `InMemoryOrderQueuer` принимает реализацию `MyQueue<T>` через кольцевой буфер.

Базовое объяснения принципа работы в `Cormen ItoA - 10.1`.

- `class RingBuffer<T> implements MyQueue<T>`
	+ в ЯП с нормальными статическими массивами для хранения данных используются они
	+ в ЯП только с динамическими массивами/списками используются они,
	но не используются встроенные методы для мутации (`push/pop/shift/unshift/append/remove etc`)
	+ отслеживает два индекса: голову и зад
	+ отслеживает текущее кол-во элементов в нем
	+ отслеживает текущий размер массива для хранения данных
		* при попытке добавить элемент когда места больше нет, выделяет новый массив нужного размера,
		копирует в него все элементы. При этом индекс головы становится `0`.
		* **БОНУС**: отслеживание избыточного расхода места и скукоживание массива.
		Только надо подумать, как не сделать этим хуже.	
	+ Никакого упоминания `Order` здесь
	+ В ЯП со стат. тип должны использоваться дженерики
- функция `main`, которая создаст все экземпляры, передаст друг другу и запустит `BuffetService.runUntilDone()`