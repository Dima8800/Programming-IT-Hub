# Очередь в студенческую столовку

На сервере очередь запросов, которые ждут обработку. Формат запросов как у команд в `3/task0`.

- `"new-order"`: получен новый заказ, который надо добавить в очередь на приготовление, с данными
    + `"id": string` - id студента, сделавшего заказ
    + `"items": FoodItem[]` - массив из id блюд в заказе
        * `FoodItem.id: string` - id блюда
        * `FoodItem.timeToCook: int` - время на приготовление блюда в условных временных единицах (сторипоинты, кек)
- `"serve-order"`: выдать заказ, который был получен раньше всех, надо его вывести и удалить. Формат вывода:
    + `{"id": string, "timeToCook": int}` - если есть заказ. `timeToCook` - суммарное время приготовления пунктов в заказе
    + `null` - если нет
- `"time-to-serve-all"`: запрос на получение суммарного времени приготовления всех заказов в очереди на текущий момент. Формат:
    + `{"total": number}`

Запросы лежат по адресу `w4/N`, где N - номер запроса начиная с 0.
Новые запросы просить, пока сервер не вернет `"cmd":"none"`.

Вывод делать POST-запросами по адресу `w4/N`, где N - номер вывода начиная с 0.

Номер вывода не совпадает с номером запроса, для которого он делается, нумерация
выводов своя.

Запрос должен идти с заголовком `Content-Type: application/json` и телом, содержащим вывод.
Сервер ответит, правильный ли вывод.

После обработки всех запросов сделать POST-запрос по адресу `w4/total`
с заголовком `Content-Type: text/plain` и телом, содержащим кол-во сделанных выводов.
Сервер ответит, правильное ли кол-во.

## Общие сущности системы

Перечисленные ниже сущности вынести в отдельную директорию в этой директории. В обеих задачах будет обращение к ним.

### Классы моделей

- `Order` - заказ
    + `getId(): string` (или `get id(): string`)
    + `getTotalTimeCook(): int` (или `get totalTimeToCook(): int`)
        * должен выполняться за `O(1)`
- `Request` - запрос, который получается с сервера
- `ServeResponse` - ответ на запрос на выдачу заказа
- `TimeResponse` - ответ на запрос на вычисление времени

### Интерфейсы компонентов

В ЯП с дин. тип. вместо интерфейсов написать классы,
методы которых ничего не делают, только выбрасывают ошибку, мол, реализуй меня.

- `RequestFetcher` - отвечает за получение запросов с сервера для обработки
    + `getNext(): Promise/Task<Request>` - получить следующий запрос
        * **БОНУС**: параллельное получение сразу пачки запросов (будет возвращать `Request[]`)
    + Должен сам держаться в курсе, какой номер следующего запроса
- `ResponsePusher` - отвечает за запушивание выводов по командам на сервер
    + `pushServe(resp: ServeResponse)`
    + `pushTime(resp: TimeResponse)`
    + `finished(): Promise/Task<bool>` - проверяет, запушены ли все выводы
- `OrderQueuer` - отвечает за хранение текущей очереди заказов
    + `addOrder(ord: Order)`
    + `serveOrder(): Order?` - `?` означает, что может вернуть `null`
    + `getTotalTimeToCook(): int` (или `get totalTimeToCook(): int`) -
    должен выполняться за `O(1)`
- `MyQueue<T>` - интерфейс обобщенной очереди
    + `putInBack(item: T)` - добавляет в конец очереди
    + `takeOffHead(): T?` - снимает элемент с начала очереди
    + Никакого упоминания `Order` здесь
    + В языках со стат. тип. использовать дженерики

### Классы компонентов

- `BuffetService` - центральный компонент системы, в котором сходится вся логика.
    + **Принимает в конструкторе** объекты, соответствующие интерфейсам выше, чтобы
        * Забирать запросы из `RequestFetcher`
        * Просить `OrderQueuer` добавлять и выдавать заказы и спрашивать оставшееся время
        * Просить `ResponsePusher` доставить выводы запросов
        * Просить `ResponsePusher` проверить, все ли выводы были сделаны,
        когда `RequestFetcher` ответит, что все запросы получены
    + `runUntilDone()` - реализует цикл выполнения
- `HTTPApiService` - сервис, в котором реализована специфика общения с сервером по HTTP: конфигурация URL, заголовков и прочая
- `HTTPRequestFetcher implements RequestFetcher` -
    реализует получение запросов с сервера по HTTP используя `HTTPApiService`,
    который ему передается в параметрах конструктора
- `HTTPResponsePusher implements ResponsePusher` -
    реализует вывод на сервер по HTTP используя `HTTPApiService`,
    который ему передается в параметрах конструктора
- `InMemoryOrderQueuer implements OrderQueuer` - хранит очередь заказов в памяти,
    использует для этого `MyQueue<Order>` и принимает экземпляр её конкретной
    реализации в параметрах конструктора
