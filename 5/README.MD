# Аналитика онлайн-активности студентов

Есть сервис, собирающий инфу об активности людей в различных сервисах,
идентифицирующий их по характерным маркерам поведения и речи
и каким-то образом оценивающий вес активности в них (чем больше, тем активнее).

Сервис отдает ЖСОН с активностью студентов, выгруженный напрямую из БД
без нормальных нормализаций.

Выглядит ЖСОН примерно так:

```json
[
    {"studId": "i00s0000", "service": "discord", "idInService": "0000", "activityWeight": 3},
    {"studId": "i00s0000", "service": "dota2",   "idInService": "0011", "activityWeight": 4},
    {"studId": "i00s0001", "service": "discord", "idInService": "0010", "activityWeight": 5},
    {"studId": "i00s0000", "service": "discord", "idInService": "0111", "activityWeight": 2},
    {"studId": "i00s0000", "service": "discord", "idInService": "0000", "activityWeight": 1}
]
```

Нужно написать сервис для трансформации этих данных в вид, более пригодный для аналитики.

Для аналитики нам надо:
- инфу по каждому студенту:
    + общее кол-во различных сервисов, в которых его задетектили
        (несколько аккаунтов в одном сервисе считаются как один)
    + общий вес активности по всем сервисам: сумма активностей по всем записям по студенту
- сводную инфу:
    + средний вес активности среди студентов
    + среднее кол-во различных сервисов по студентам

Чтобы избежать ошибок округления при (де)сериализации, все числа надо преобразовать в строки.
Числа по студентам должны быть целыми, средние округлить до 1 знака после запятой.

Аналитика получится такая:

```json
{
    "avgWeight": "7.5",
    "avgServicesUsed": "1.5",
    "byStudent": {
        "i00s0000": {
            "servicesUsed": "2",
            "totalWeight": "10"
        },
        "i00s0001": {
            "servicesUsed": "1",
            "totalWeight": "5"
        }
    }
}
```

Базовый URL (до `api/` включительно) как обычно.

`GET` `w5/N` - получить дамп БД под номером `N`.

`POST` `w5/N` - проверить получившуюся аналитику для дампа под номером `N`.

`N = 0`: тестовый маленький ЖСОН, чтобы можно было руками-глазами проверить правильность алгоритмов.

`N = 1`: большой проверочный ЖСОН.

Конечное решение должно дергать только `N = 1`.

## Требования к реализации

Само вычисление данных должно выполняться за `O(n)`, где `n` - кол-во записей в дампе.

Чтобы этого добиться, придется использовать
- HashMap для быстрого поиска соответствия студента и данных по нему
- HashSet для быстрого учета кол-ва используемых студентом сервисов

Что должно быть (в ЯП с дин. тип. описание интерфейсов не обязательно,
но классы должны их точно реализовывать):

1. `interface MyHashable`:
```java
interface MyHashable {
    int hashMeDaddy();
}
```
2. `class MyHashMap`, который реализует хэш-таблицу, в которой ключом может быть любой объект,
    реализующий интерфейс `MyHashable` (доп. методы на свое усмотрение):
```java
class MyHashMap<K implements MyHashable, V> {
    // Сложности указаны амортизированные и без учета сложности вычисления хэша ключа
    void mapKeyVal(K key, V val);   // сохраняет значение по ключу. O(1)
    V mapKey(K key);    // возвращает значение, записаное по ключу, либо null, если такого нет. O(1)
    void delKey(K key);     // удаляет запись по ключу. O(1)
    int size(); // возвращает текущее кол-во записей. O(1)
    K[] keys();	// возвращает массив/список из сохраненных сейчас ключей. O(n)
}
```
3. `class MyHashSet`, который реализует множество на основе `MyHashMap` (доп. методы на свое усмотрение):
```java
class MyHashSet<V implements MyHashable> {
    private MyHashMap<V, V> map;

    // Сложности указаны амортизированные и без учета сложности вычисления хэша ключа
    void add(V val);    // сохраняет элемент, если его ещё нет. O(1)
    bool has(V val);    // содержит ли множество этот элемент. O(1)
    void del(V val);    // удаляет элемент. O(1)
    int size(); // возвращает текущее кол-во элементов. O(1)
    V[] vals();	// возвращает массив/список из сохраненных сейчас значений. O(n)
}
```
4. Данные, которые будут храниться как ключи `MyHashMap` или элементы `MyHashSet`,
    должны быть завернуты в классы, реализующие `MyHashable`
    Реализация алгоритма хэширования в `hashMeDaddy` не должна использовать готовые библиотеки
    хэширования, а должна быть написана самостоятельно.
    Придумывать свой собственный алгоритм необязательно, но полезно.
5. `class HTTPApiService` - инкапсулирует в себе всю работу с API, выставляет два метода
```java
class HTTPApiService {
    JsonOrStringOrSomethingDecideYourself getActivity(SomeArgsButNotStudIdOrURLOrAnythingLikeThat);

    JsonOrStringOrSomethingDecideYourself postAnal(SomeArgsButNotStudIdOrURLOrAnythingLikeThat);
}
```
6. Какой-то класс, который это все связывает и реализует алгоритм трансформации, использующий
    `MyHashMap` и `MyHashSet`.
7. `MyHashMap` должна быть реализована самостоятельно.
    - Внутри использовать статический массив, пересоздавать его при превышении
        коэффициента заполнения и перехэшировать таблицу.
    - Должна быть возможность настраивать коэффициент заполнения при создании экземпляра.
    - Механизм разрешения коллизий выбрать на свой вкус. Если использовать метод списков,
        то использовать самостоятельную реализацию связного списка.